{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blino Maker Boards Documentation On this site you will find documentation which covers both the Tee-Naps and Pi-Naps Blino EEG Maker Boards. Included is: Hardware information Setup and installation Software Use","title":"Blino"},{"location":"#blino-maker-boards-documentation","text":"On this site you will find documentation which covers both the Tee-Naps and Pi-Naps Blino EEG Maker Boards. Included is: Hardware information Setup and installation Software Use","title":"Blino Maker Boards Documentation"},{"location":"devices_pi/","text":"Pi-Naps_v0.2 Pi-Naps is a Raspberry Pi Shield which provides a single channel EEG signal using three electrodes, with one positioned on the forehead and two on an ear clip. This shield is designed to fit the form factor of the Raspberry Pi Zero, facilitating the creation of portable and highly configurable Brain Computer Interfaces. It should be noted however, that due to the performance limitations of the Raspberry Pi Zero, not all features work correctly when using a Pi Zero and so it is important to see the documentation concerning Raspberry Pi integrations. Note: We are working to provide solutions to these limitations and will be developing updates for Pi zero compatibility through 2019 . EEG Output Modes Pi-Naps provides the ability to measure hardware accelerated FFT values (EEG Power spectrum) which shows the amount of energy in a given frequency range. These values are computed on the EEG sensor chip on board the Pi-Naps shield, meaning there is no need to spend processing power on performing these relatively costly computations. The EEG power spectrum is generally useful when starting to build BCI (Brain Computer Interfaces). Further, Pi-naps provides two values for measuring the attention and meditation values, based on Neurosky's proprietary algorithms. We cover the meaning of these values in detail in the EEG section . There are currently 3 operating modes available for use with Pi-Naps: MODE_BASIC Basic mode provides the following data outputs: Signal quality Attention Value Meditation value EEG Power Values (Hardware accelerated FFT) Mode_EEG_Raw Signal quality Attention Value Meditation value EEG value Mode_FFT Signal quality Attention Value Meditation value EEG value EEG Power Values (Hardware accelerated FFT) Device Compatibility Raspberry Pi zero Currently, there are limitations for the Raspberry Pi zero , meaning it can only operate in the the basic mode (Mode_Basic). This is due to constraints of the Pi zero's hardware buffer size, restricting the amount of data it can handle. The Pi zero remains useful for most portable applications, with the core functionality available. For most cases, it is better to utilise the EEG powers or the meditation/attention values as you can start to consider the properties of the Brain activity without having to do expensive processing. Note: We are working on solutions to unlock all features on the pi zero as well in the future. Form Factor Pi-Naps features a through hole header maximising compatibility with your current projects. This header design also allows for a low profile fit on top of a male header when fitted to the Pi Zero, making it optimal for wearable projects. Further, it is easy to adapt to the form factor of your Pi project without having to solder headers. This helps avoid the need for awkward soldering tasks on the Pi-Naps shield between projects which can result in damage if not performed carefully. Pi-Naps allows for stacking with other shields using long headers. This stacking capability is further emphasised by allowing a switchable method for communication between Pi-Naps and the Raspberry Pi. Choose between UART or I2C to ensure that there are no pin collisions with other devices/projects. Electrodes Electrodes can be attached with a number of options. Pi-Naps offers three main methods for attachment. On the top there are two female jack plugs (one TRS, one TS), allowing you to easily plug the electrodes in and start measuring. There are also pads to attach a Dupont connector or directly solder electrodes, exposed on the underside of the board. If custom electrodes are required, it should be noted that the ear reference channel requires shield, voltage ref and reference and the main signal electrode requires shield and signal. For DIY electrodes, a quality, shielded audio cable is typically the best option, providing the shielded, dual core cable that best suits Pi-Naps_v0.2 electrodes. Electrodes are covered in more detail in the section on electrodes and details on DIY electrodes can be found on the Blino Blog or Forums . Battery In order to control interference and allow for portable integrations, Pi-Naps features built in battery management for Lithium Ion batteries. The micro USB port found on the shield handles charging the battery. There is an LED indicator to indicate the charging status. This light goes off to indicate a fully charged battery. The switch on the Pi-Naps disconnects the battery. In the on position, power is allowed to flow to both the Rasberry Pi and the Pi-Naps. When plugged in the battery will charge no matter what the position of the switch. If the battery is not being used, power directly to the Raspberry Pi as normal (which will then power Pi-Naps). With a battery attached, this shield will power the Raspberry Pi it is mounted to. Quality batteries with independent protection should be used with Pi-Naps, particularly when used for wearable applications. Note that battery life is dependent on a number of factors and is primarily limited by the need to power the Raspberry Pi. If long battery life are desirable, with a small battery, we would recommend the Tee-Naps shield for Teensy 3.2 or subscription to keep up with our future releases... Config Configuration of the Pi-Naps shield is carried out with a combination of software calls and solder pads, exposed on the underside of Pi-Naps.","title":"Pi-Naps_v0.2"},{"location":"devices_pi/#pi-naps_v02","text":"Pi-Naps is a Raspberry Pi Shield which provides a single channel EEG signal using three electrodes, with one positioned on the forehead and two on an ear clip. This shield is designed to fit the form factor of the Raspberry Pi Zero, facilitating the creation of portable and highly configurable Brain Computer Interfaces. It should be noted however, that due to the performance limitations of the Raspberry Pi Zero, not all features work correctly when using a Pi Zero and so it is important to see the documentation concerning Raspberry Pi integrations. Note: We are working to provide solutions to these limitations and will be developing updates for Pi zero compatibility through 2019 .","title":"Pi-Naps_v0.2"},{"location":"devices_pi/#eeg-output-modes","text":"Pi-Naps provides the ability to measure hardware accelerated FFT values (EEG Power spectrum) which shows the amount of energy in a given frequency range. These values are computed on the EEG sensor chip on board the Pi-Naps shield, meaning there is no need to spend processing power on performing these relatively costly computations. The EEG power spectrum is generally useful when starting to build BCI (Brain Computer Interfaces). Further, Pi-naps provides two values for measuring the attention and meditation values, based on Neurosky's proprietary algorithms. We cover the meaning of these values in detail in the EEG section . There are currently 3 operating modes available for use with Pi-Naps:","title":"EEG Output Modes"},{"location":"devices_pi/#mode_basic","text":"Basic mode provides the following data outputs: Signal quality Attention Value Meditation value EEG Power Values (Hardware accelerated FFT)","title":"MODE_BASIC"},{"location":"devices_pi/#mode_eeg_raw","text":"Signal quality Attention Value Meditation value EEG value","title":"Mode_EEG_Raw"},{"location":"devices_pi/#mode_fft","text":"Signal quality Attention Value Meditation value EEG value EEG Power Values (Hardware accelerated FFT)","title":"Mode_FFT"},{"location":"devices_pi/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"devices_pi/#raspberry-pi-zero","text":"Currently, there are limitations for the Raspberry Pi zero , meaning it can only operate in the the basic mode (Mode_Basic). This is due to constraints of the Pi zero's hardware buffer size, restricting the amount of data it can handle. The Pi zero remains useful for most portable applications, with the core functionality available. For most cases, it is better to utilise the EEG powers or the meditation/attention values as you can start to consider the properties of the Brain activity without having to do expensive processing. Note: We are working on solutions to unlock all features on the pi zero as well in the future.","title":"Raspberry Pi zero"},{"location":"devices_pi/#form-factor","text":"Pi-Naps features a through hole header maximising compatibility with your current projects. This header design also allows for a low profile fit on top of a male header when fitted to the Pi Zero, making it optimal for wearable projects. Further, it is easy to adapt to the form factor of your Pi project without having to solder headers. This helps avoid the need for awkward soldering tasks on the Pi-Naps shield between projects which can result in damage if not performed carefully. Pi-Naps allows for stacking with other shields using long headers. This stacking capability is further emphasised by allowing a switchable method for communication between Pi-Naps and the Raspberry Pi. Choose between UART or I2C to ensure that there are no pin collisions with other devices/projects.","title":"Form Factor"},{"location":"devices_pi/#electrodes","text":"Electrodes can be attached with a number of options. Pi-Naps offers three main methods for attachment. On the top there are two female jack plugs (one TRS, one TS), allowing you to easily plug the electrodes in and start measuring. There are also pads to attach a Dupont connector or directly solder electrodes, exposed on the underside of the board. If custom electrodes are required, it should be noted that the ear reference channel requires shield, voltage ref and reference and the main signal electrode requires shield and signal. For DIY electrodes, a quality, shielded audio cable is typically the best option, providing the shielded, dual core cable that best suits Pi-Naps_v0.2 electrodes. Electrodes are covered in more detail in the section on electrodes and details on DIY electrodes can be found on the Blino Blog or Forums .","title":"Electrodes"},{"location":"devices_pi/#battery","text":"In order to control interference and allow for portable integrations, Pi-Naps features built in battery management for Lithium Ion batteries. The micro USB port found on the shield handles charging the battery. There is an LED indicator to indicate the charging status. This light goes off to indicate a fully charged battery. The switch on the Pi-Naps disconnects the battery. In the on position, power is allowed to flow to both the Rasberry Pi and the Pi-Naps. When plugged in the battery will charge no matter what the position of the switch. If the battery is not being used, power directly to the Raspberry Pi as normal (which will then power Pi-Naps). With a battery attached, this shield will power the Raspberry Pi it is mounted to. Quality batteries with independent protection should be used with Pi-Naps, particularly when used for wearable applications. Note that battery life is dependent on a number of factors and is primarily limited by the need to power the Raspberry Pi. If long battery life are desirable, with a small battery, we would recommend the Tee-Naps shield for Teensy 3.2 or subscription to keep up with our future releases...","title":"Battery"},{"location":"devices_pi/#config","text":"Configuration of the Pi-Naps shield is carried out with a combination of software calls and solder pads, exposed on the underside of Pi-Naps.","title":"Config"},{"location":"devices_tee/","text":"Tee-Naps Tee-Naps is the simplified partner device to Pi-Naps, providing the same single channel EEG as Pi-Naps in a highly compact form factor. The shield is designed to work primarily with the Teensy 3.2 (with future support for Arduino) and is programmed in C using the Teensy version of Arduino IDE. Tee-Naps is available but is currently being produced to order only, currently. To find out more, get in touch.","title":"Tee-Naps"},{"location":"devices_tee/#tee-naps","text":"Tee-Naps is the simplified partner device to Pi-Naps, providing the same single channel EEG as Pi-Naps in a highly compact form factor. The shield is designed to work primarily with the Teensy 3.2 (with future support for Arduino) and is programmed in C using the Teensy version of Arduino IDE. Tee-Naps is available but is currently being produced to order only, currently. To find out more, get in touch.","title":"Tee-Naps"},{"location":"eeg/","text":"EEG The values produced by the first generation Blino 'Maker boards' (Pi-Naps_v0.2 and Tee-Naps_v0.2) are outlined in this section. Attention The attention value represents the intensity of the current mental 'focus' or 'attention'. The attention level increases when the subject is focused on single task or object within the range 0-100. These values are executed in hardware on the EEG sensor mounted to Pi-Naps_v0.2. The algorithm is implemented by Neurosky and the concept for deriving these values is outlined in their white paper : \"BCI: Entertainment's Brain Hacking Tool for Control and Monitoring\" . Meditation The attention value represents the intensity of the current mental 'calmness' or 'relaxation'. The attention level increases when the subject relax their mind and decreases when 'uneasy' or 'stressed' within the range 0-100. These values are executed in hardware on the EEG sensor mounted to Pi-Naps_v0.2. The algorithm is implemented by Neurosky and the concept for deriving these values is outlined in their white paper : \"BCI: Entertainment's Brain Hacking Tool for Control and Monitoring\" . EEG Power Values The EEG Power values are hardware accelerated FFT meaning you do not pay the cost of performing the calculations involved in a fast Fourier transform, freeing up processing power for your application and getting useful information faster. The values produced by this transform represent the relative power within the frequency range (indicated in the table below). This can be used to infer certain properties about brain activity however, this is the challenge we leave to you, as we do not yet have resources on this topic. The values produced here do not represent any real world units - in order to analyse and use these values they must be evaluated in a relative manner, considering temporal changes and comparing quantities only to itself(ie. number output from the current transform). The values will change (potentially by orders of magnitude) depending on a number of environmental factors, the person wearing the electrodes and the connection quality. Name Frequency Range Delta 0.5 - 2.75Hz Theta 3.5 - 6.75Hz Low-Alpha 7.5 - 9.25Hz High-Alpha 10 - 11.75Hz Low-Beta 13 - 16.75Hz High-Beta 18 - 29.75Hz Low-Gamma 31 - 39.75Hz Mid-Gamma 41 - 49.75Hz These values are represented by Integers that represent up to 24 bits worth of values. Remember: These values represent the amount of power within the respective frequency band. A simple exercise: Start by seeing if you can equate closing your eyes to an increase in alpha activity by recording and plotting a session EEG value These values consist of raw EEG represented by 16bit signed integer values. They are output 512 times per second (approx. every 2ms). Due to the noise floor of the signal, it should be noted that only the 12 most significant bits are relevant for processing this signal. As such you will only see values that fit this range and not the full range of 16bit integers. Signal Quality","title":"EEG"},{"location":"eeg/#eeg","text":"The values produced by the first generation Blino 'Maker boards' (Pi-Naps_v0.2 and Tee-Naps_v0.2) are outlined in this section.","title":"EEG"},{"location":"eeg/#attention","text":"The attention value represents the intensity of the current mental 'focus' or 'attention'. The attention level increases when the subject is focused on single task or object within the range 0-100. These values are executed in hardware on the EEG sensor mounted to Pi-Naps_v0.2. The algorithm is implemented by Neurosky and the concept for deriving these values is outlined in their white paper : \"BCI: Entertainment's Brain Hacking Tool for Control and Monitoring\" .","title":"Attention"},{"location":"eeg/#meditation","text":"The attention value represents the intensity of the current mental 'calmness' or 'relaxation'. The attention level increases when the subject relax their mind and decreases when 'uneasy' or 'stressed' within the range 0-100. These values are executed in hardware on the EEG sensor mounted to Pi-Naps_v0.2. The algorithm is implemented by Neurosky and the concept for deriving these values is outlined in their white paper : \"BCI: Entertainment's Brain Hacking Tool for Control and Monitoring\" .","title":"Meditation"},{"location":"eeg/#eeg-power-values","text":"The EEG Power values are hardware accelerated FFT meaning you do not pay the cost of performing the calculations involved in a fast Fourier transform, freeing up processing power for your application and getting useful information faster. The values produced by this transform represent the relative power within the frequency range (indicated in the table below). This can be used to infer certain properties about brain activity however, this is the challenge we leave to you, as we do not yet have resources on this topic. The values produced here do not represent any real world units - in order to analyse and use these values they must be evaluated in a relative manner, considering temporal changes and comparing quantities only to itself(ie. number output from the current transform). The values will change (potentially by orders of magnitude) depending on a number of environmental factors, the person wearing the electrodes and the connection quality. Name Frequency Range Delta 0.5 - 2.75Hz Theta 3.5 - 6.75Hz Low-Alpha 7.5 - 9.25Hz High-Alpha 10 - 11.75Hz Low-Beta 13 - 16.75Hz High-Beta 18 - 29.75Hz Low-Gamma 31 - 39.75Hz Mid-Gamma 41 - 49.75Hz These values are represented by Integers that represent up to 24 bits worth of values. Remember: These values represent the amount of power within the respective frequency band. A simple exercise: Start by seeing if you can equate closing your eyes to an increase in alpha activity by recording and plotting a session","title":"EEG Power Values"},{"location":"eeg/#eeg-value","text":"These values consist of raw EEG represented by 16bit signed integer values. They are output 512 times per second (approx. every 2ms). Due to the noise floor of the signal, it should be noted that only the 12 most significant bits are relevant for processing this signal. As such you will only see values that fit this range and not the full range of 16bit integers.","title":"EEG value"},{"location":"eeg/#signal-quality","text":"","title":"Signal Quality"},{"location":"electrodes/","text":"Electrodes [ Pi-Naps_v0.2 ] There are three options available for connecting electrodes to Pi-Naps. Solder Pads Dupont 2.5mm Jack Solder You may solder your wire directly to the solder pads exposed on the underside of the board. This will give you a fixed attachment. You should bear in mind the effects of fatigue when using this setup and design a case (or some other setup) that fixs the electrode cable and takes any potential strain. Dupont Pi-Naps can be ordered with pins fitted to the board, allowing for compatability with dupont connectors. This can be useful for home made electrode applications and low cost testing. The solder pads on the underside of Pi-Naps match the footprint for SMT type right angle 2.54mm headers. These can easily be added and removed at the users convenience. 2.5mm jack Our 2.5mm Jack electrodes are expected to arrive on our store within the next month The recommended method for attaching electrodes to Pi-Naps is using 2.5mm jacks. This is not currently a standard connector for EEG electrodes and as such we have had electrodes made especially for this application. So far we have found the performance of jack connectors to be effective in terms of noise and the obvious connvience is a excellent benefit for many applications. Jacks make it easy to transport, minimise fatigue on the connector and allow for easy changes between different cables. Electrode Wiring [ Pi-Naps_v0.2 ] Electrodes used with Pi-Naps (and Tee-Naps) are split into two wires typically. The Forehead electrode requires a single core cable which is shielded. The Ear Reference requires a two core cable, that is shielded. It is likely easiest to use twin core, shielded wire and only use one core for the forehead electrode.","title":"Electrodes"},{"location":"electrodes/#electrodes-pi-naps_v02","text":"There are three options available for connecting electrodes to Pi-Naps. Solder Pads Dupont 2.5mm Jack","title":"Electrodes [ Pi-Naps_v0.2 ]"},{"location":"electrodes/#solder","text":"You may solder your wire directly to the solder pads exposed on the underside of the board. This will give you a fixed attachment. You should bear in mind the effects of fatigue when using this setup and design a case (or some other setup) that fixs the electrode cable and takes any potential strain.","title":"Solder"},{"location":"electrodes/#dupont","text":"Pi-Naps can be ordered with pins fitted to the board, allowing for compatability with dupont connectors. This can be useful for home made electrode applications and low cost testing. The solder pads on the underside of Pi-Naps match the footprint for SMT type right angle 2.54mm headers. These can easily be added and removed at the users convenience.","title":"Dupont"},{"location":"electrodes/#25mm-jack","text":"Our 2.5mm Jack electrodes are expected to arrive on our store within the next month The recommended method for attaching electrodes to Pi-Naps is using 2.5mm jacks. This is not currently a standard connector for EEG electrodes and as such we have had electrodes made especially for this application. So far we have found the performance of jack connectors to be effective in terms of noise and the obvious connvience is a excellent benefit for many applications. Jacks make it easy to transport, minimise fatigue on the connector and allow for easy changes between different cables.","title":"2.5mm jack"},{"location":"electrodes/#electrode-wiring-pi-naps_v02","text":"Electrodes used with Pi-Naps (and Tee-Naps) are split into two wires typically. The Forehead electrode requires a single core cable which is shielded. The Ear Reference requires a two core cable, that is shielded. It is likely easiest to use twin core, shielded wire and only use one core for the forehead electrode.","title":"Electrode Wiring [ Pi-Naps_v0.2 ]"},{"location":"pi-naps/","text":"Quick Start pip install pinaps pip install SC16IS750 sudo raspi-config Select interfacing options from menu. Select serial from menu. Select no to shell use over serial . Select yes to enabling serial port hardware . sudo raspi-config Select interfacing options from menu. Select I2C from menu. Select yes to enable ARM I2C interface. Clone our examples repository somewhere appropriate: git clone https://Blino_Tech@bitbucket.org/blino-dev/pinaps.git Run an example script - don't forget to plug your electrodes in! cd pi-naps_examples/ python meditate.py Installation The installation of the Pi-Naps library should be as simple as using pip to install the online distribution. From then onwards you can import it into your scripts and use the library classes (See Usage ) pip install pinaps Alternatively, the original repository can be cloned into a directory and used locally from there: git clone https://Blino_Tech@bitbucket.org/blino-dev/pinaps.git This is the best way of running the examples straight away and testing the library out. Installing I2C Driver The Pi-Naps uses an I2C chip as an interface to communicate with the EEG sensor and for configuring some pinouts on the board. This requires a standalone driver which may need installing separately. If you need to install the I2C driver separately required to use the Pi-Naps: pip install SC16IS750 Alternatively, the original repository can be cloned into the Pi-Naps repository: git clone https://github.com/Harri-Renney/SC16IS750-Python-Driver.git (See https://github.com/Harri-Renney/SC16IS750-Python-Driver ) Serial Port Configuration In order for you to use the serial interface on your Raspberry Pi Zero, you may need to configure the OS to enable its use. 1.Run raspi-config from command line. sudo raspi-config 2.Select interfacing options from menu. 3.Select serial from menu. 4.Select no to shell use over serial. 5.Select yes to enabling serial port hardware. I2C Configuration In order for you to use the I2C interface on your Raspberry Pi Zero, you may need to configure the OS to enable its use. 1.Run raspi-config from command line. sudo raspi-config 2.Select interfacing options from menu. 3.Select I2C from menu. 4.Select yes to enable ARM I2C interface. Raspberry Pi Compatibility Pi Zero This shield is designed to fit the form factor of the Raspberry Pi Zero, facilitating the creation of portable and highly configurable Brain Computer Interfaces. It should be noted however, that due to the performance limitations of the Raspberry Pi Zero, not all features work correctly when using a Pi Zero and so it is important to see the documentation concerning Raspberry Pi integrations. Current limitations are: Restricted to \" Basic_Mode \" output mode Note: We are working to provide solutions to these limitations and will be developing updates for Pi zero compatability through 2019 . Pi 3b Using the Pi 3b currently facilitates access to the full potential of the Pi-Naps_v0.2 providing the option to record RAW EEG and FFT simultaneously. Library Usage There are two main classes that cover all required functionality. The Pi-NapsController is for controlling the Pi-Naps hardware. The BlinoParser is used for parsing the data retrieved from the EEG sensor into the values that Pi-Naps can produce. PiNapsController The Pi-NapsController allows for control over the Pi-Naps shield, allowing access to LED and Button ( Button: supported coming soon ) as well as device configuration. The EEG Sensor is read from the Controller and data should be passed into the BlinoParser to parse into useful information. The controller can also configure what pins EEG data is transferred over, allowing for configuration of your project in software. It's important to import the PiNapsController with the form from pinaps.piNapsController import PiNapsController to ensure correct operation. Below is a script demonstrating typical a typical setup and use of PiNapsController from pinaps.piNapsController import PiNapsController # First the controller is initalized and setup with desired control # Create a PiNapsController object: controller = PiNapsController() # Select how Pi-Naps is controlled : options are using I2C or UART. # If you are unsure we recommend I2C for maximising compatability and functionality. controller.setControlInterfaceI2C() # Setup the use of I2C interface in communication with EEG sensor chip: controller.setEEGSensorInterfaceI2C() # Set the desired mode for the EEG chip to operate in. #For Raspberry Pi Zero: # ONlY BASIC MODE IS CURRENTLY SUPPORTED controller.setModeBasic() #Raspberry Pi 3 etc have full access.... # controller.setModeEEGRaw() # controller.setModeFFT() # From this point, any available EEG data from the board when ready can be detected using: while(1): if(controller.dataWaiting() > 0): data = controller.readEEGSensor() #We then parse data to the parser to make more sense of it! parser.parseByte(data) We may consider these modes in more detail: Control Interface The control interface is the setting describing how the Raspberry Pi and Pi-Naps shield should comunicate. You may control the shield using the I2C bus (which is recomended for full featured operation), or using the GPIO pins. In general, we recommend using the I2C setting and would only change this, if we had a specific reason to completely reserve the I2C bus. # Functions for configuration of Controlling Pi-Naps from pinaps.piNapsController import PiNapsController controller = PinapsController() # We have two main ways to set the control method # Using a parameter controller.setControlInterface(controller.Control.I2C) controller.setControlInterface(controller.Control.GPIO) # Etc ... # Or with a direct function call for more convenience controller.setControlInterfaceI2C() controller.setControlInterfaceGPIO() # Etc ... EEG Sensor Interface The EEG sensor interface allows you to set the pins over which the EEG data itself is transfered. Again we recomend I2C for this, however this can also be set to use UART. Again, this is done to allow for avoiding collisions with other projects or devices. # Functions for configuration of setting Pi-Naps EEG sensor communication channel from pinaps.piNapsController import PiNapsController controller = PinapsController() # We have two main ways to set the control method # Using a parameter controller.setEEGSensorInterface(controller.Interface.I2C) controller.setEEGSensorInterface(controller.Interface.UART) # Etc ... # Or with a direct function call for more convenience controller.setEEGSensorInterfaceI2C() controller.setEEGSensorInterfaceUART() # Etc ... Pi-Naps Mode (Data Output Mode) The 'Mode' configures what data the EEG sensor produces. Notably: The Rasberry Pi Zero can currently only operate in Basic Mode. The Modes are as follows: setBasicMode() Basic mode provides the following data points: - Signal Quality - Meditation Value - Attention Value - EEG powers ( FFT ) \u200b setRawEEGMode() Raw EEG mode provides the following data points: Signal Quality Meditation Value Attention Value Raw EEG Signal setFFTMode() FFT mode provides the following data points: Signal Quality Meditation Value Attention Value Raw EEG Signal EEG powers ( FFT ) \u200b BlinoParser The Blino parser, transaltes the stream of bytes from the Pi-Naps into meaningful more information. It's important to import the BlinoParser correctly. Just use the following code at the beginning of your script if you are unsure. from pinaps.blinoParser import BlinoParser There are two methods for working with the parsed information: 1. Callbacks The prefered method for handling data is to use callbacks. We simply create a function to work with the relevant data and then register that function for use with Here a function is defined, simply to print the attention value: def onAttentionRecieved(attention): print(\"Attention value: %d\" % attention) ... Now when a parser is created, and processes a new attention value a callback is triggered. If we register the previously defined callback, it will execute on every new value recieved. We may register the function as follows: #Create parser. parser = BlinoParser() #Register the attentionCallback function with the parser. parser.attentionCallback = onAttentionRecieved 2. Returning Packets The parseByte function returns the latest packet. It is advisable to check with a conditional that the packet has been updated before using it. This is advised as not every iteration a byte is parsed is new information updated in the packet. Check the object's \"updated\" member variable. returnedPacket = parser.parseByte(data) if(returnedPacket.updated): print(\"Delta Value = %d\" % returnedPacket.EEGPower.delta) Alternatively, the latest packet can be retrieved from the parsedPacket: currentPacket = parser.parsedPacket print(\"meditation value = %d\" % currentPacket.meditation) Troubleshooting Pip Install If you're having trouble using pip install. Try using: python -m pip install --index-url https://pypi.org/simple/ example_pkg Where the url is the project url and the example_pkg is the package you wish to install. Python Library Path You might be having a lot of trouble finding where to install the libraries manually for global use. On raspbian it should look something like this: \"usr/local/lib/python2.7/dist-packages\" A lot of unnecessary trouble can come of this, especially if you are not confident in using linux and more specifically Raspbian. In which case, we advise to just clone the repository into a local directory and create your script in there, with the library files in the same directory. ___Additional Dependencies Error__ During pip install of Pi-Naps. If an error occours specifically around installing any addtional dependencies. Use --no-dependencies flag.","title":"Pi-Naps"},{"location":"pi-naps/#quick-start","text":"pip install pinaps pip install SC16IS750 sudo raspi-config Select interfacing options from menu. Select serial from menu. Select no to shell use over serial . Select yes to enabling serial port hardware . sudo raspi-config Select interfacing options from menu. Select I2C from menu. Select yes to enable ARM I2C interface. Clone our examples repository somewhere appropriate: git clone https://Blino_Tech@bitbucket.org/blino-dev/pinaps.git Run an example script - don't forget to plug your electrodes in! cd pi-naps_examples/ python meditate.py","title":"Quick Start"},{"location":"pi-naps/#installation","text":"The installation of the Pi-Naps library should be as simple as using pip to install the online distribution. From then onwards you can import it into your scripts and use the library classes (See Usage ) pip install pinaps Alternatively, the original repository can be cloned into a directory and used locally from there: git clone https://Blino_Tech@bitbucket.org/blino-dev/pinaps.git This is the best way of running the examples straight away and testing the library out.","title":"Installation"},{"location":"pi-naps/#installing-i2c-driver","text":"The Pi-Naps uses an I2C chip as an interface to communicate with the EEG sensor and for configuring some pinouts on the board. This requires a standalone driver which may need installing separately. If you need to install the I2C driver separately required to use the Pi-Naps: pip install SC16IS750 Alternatively, the original repository can be cloned into the Pi-Naps repository: git clone https://github.com/Harri-Renney/SC16IS750-Python-Driver.git (See https://github.com/Harri-Renney/SC16IS750-Python-Driver )","title":"Installing I2C Driver"},{"location":"pi-naps/#serial-port-configuration","text":"In order for you to use the serial interface on your Raspberry Pi Zero, you may need to configure the OS to enable its use. 1.Run raspi-config from command line. sudo raspi-config 2.Select interfacing options from menu. 3.Select serial from menu. 4.Select no to shell use over serial. 5.Select yes to enabling serial port hardware.","title":"Serial Port Configuration"},{"location":"pi-naps/#i2c-configuration","text":"In order for you to use the I2C interface on your Raspberry Pi Zero, you may need to configure the OS to enable its use. 1.Run raspi-config from command line. sudo raspi-config 2.Select interfacing options from menu. 3.Select I2C from menu. 4.Select yes to enable ARM I2C interface.","title":"I2C Configuration"},{"location":"pi-naps/#raspberry-pi-compatibility","text":"","title":"Raspberry Pi Compatibility"},{"location":"pi-naps/#pi-zero","text":"This shield is designed to fit the form factor of the Raspberry Pi Zero, facilitating the creation of portable and highly configurable Brain Computer Interfaces. It should be noted however, that due to the performance limitations of the Raspberry Pi Zero, not all features work correctly when using a Pi Zero and so it is important to see the documentation concerning Raspberry Pi integrations. Current limitations are: Restricted to \" Basic_Mode \" output mode Note: We are working to provide solutions to these limitations and will be developing updates for Pi zero compatability through 2019 .","title":"Pi Zero"},{"location":"pi-naps/#pi-3b","text":"Using the Pi 3b currently facilitates access to the full potential of the Pi-Naps_v0.2 providing the option to record RAW EEG and FFT simultaneously.","title":"Pi 3b"},{"location":"pi-naps/#library","text":"","title":"Library"},{"location":"pi-naps/#usage","text":"There are two main classes that cover all required functionality. The Pi-NapsController is for controlling the Pi-Naps hardware. The BlinoParser is used for parsing the data retrieved from the EEG sensor into the values that Pi-Naps can produce.","title":"Usage"},{"location":"pi-naps/#pinapscontroller","text":"The Pi-NapsController allows for control over the Pi-Naps shield, allowing access to LED and Button ( Button: supported coming soon ) as well as device configuration. The EEG Sensor is read from the Controller and data should be passed into the BlinoParser to parse into useful information. The controller can also configure what pins EEG data is transferred over, allowing for configuration of your project in software. It's important to import the PiNapsController with the form from pinaps.piNapsController import PiNapsController to ensure correct operation. Below is a script demonstrating typical a typical setup and use of PiNapsController from pinaps.piNapsController import PiNapsController # First the controller is initalized and setup with desired control # Create a PiNapsController object: controller = PiNapsController() # Select how Pi-Naps is controlled : options are using I2C or UART. # If you are unsure we recommend I2C for maximising compatability and functionality. controller.setControlInterfaceI2C() # Setup the use of I2C interface in communication with EEG sensor chip: controller.setEEGSensorInterfaceI2C() # Set the desired mode for the EEG chip to operate in. #For Raspberry Pi Zero: # ONlY BASIC MODE IS CURRENTLY SUPPORTED controller.setModeBasic() #Raspberry Pi 3 etc have full access.... # controller.setModeEEGRaw() # controller.setModeFFT() # From this point, any available EEG data from the board when ready can be detected using: while(1): if(controller.dataWaiting() > 0): data = controller.readEEGSensor() #We then parse data to the parser to make more sense of it! parser.parseByte(data) We may consider these modes in more detail:","title":"PiNapsController"},{"location":"pi-naps/#control-interface","text":"The control interface is the setting describing how the Raspberry Pi and Pi-Naps shield should comunicate. You may control the shield using the I2C bus (which is recomended for full featured operation), or using the GPIO pins. In general, we recommend using the I2C setting and would only change this, if we had a specific reason to completely reserve the I2C bus. # Functions for configuration of Controlling Pi-Naps from pinaps.piNapsController import PiNapsController controller = PinapsController() # We have two main ways to set the control method # Using a parameter controller.setControlInterface(controller.Control.I2C) controller.setControlInterface(controller.Control.GPIO) # Etc ... # Or with a direct function call for more convenience controller.setControlInterfaceI2C() controller.setControlInterfaceGPIO() # Etc ...","title":"Control Interface"},{"location":"pi-naps/#eeg-sensor-interface","text":"The EEG sensor interface allows you to set the pins over which the EEG data itself is transfered. Again we recomend I2C for this, however this can also be set to use UART. Again, this is done to allow for avoiding collisions with other projects or devices. # Functions for configuration of setting Pi-Naps EEG sensor communication channel from pinaps.piNapsController import PiNapsController controller = PinapsController() # We have two main ways to set the control method # Using a parameter controller.setEEGSensorInterface(controller.Interface.I2C) controller.setEEGSensorInterface(controller.Interface.UART) # Etc ... # Or with a direct function call for more convenience controller.setEEGSensorInterfaceI2C() controller.setEEGSensorInterfaceUART() # Etc ...","title":"EEG Sensor Interface"},{"location":"pi-naps/#pi-naps-mode-data-output-mode","text":"The 'Mode' configures what data the EEG sensor produces. Notably: The Rasberry Pi Zero can currently only operate in Basic Mode. The Modes are as follows: setBasicMode() Basic mode provides the following data points: - Signal Quality - Meditation Value - Attention Value - EEG powers ( FFT ) \u200b setRawEEGMode() Raw EEG mode provides the following data points: Signal Quality Meditation Value Attention Value Raw EEG Signal setFFTMode() FFT mode provides the following data points: Signal Quality Meditation Value Attention Value Raw EEG Signal EEG powers ( FFT ) \u200b","title":"Pi-Naps Mode (Data Output Mode)"},{"location":"pi-naps/#blinoparser","text":"The Blino parser, transaltes the stream of bytes from the Pi-Naps into meaningful more information. It's important to import the BlinoParser correctly. Just use the following code at the beginning of your script if you are unsure. from pinaps.blinoParser import BlinoParser There are two methods for working with the parsed information:","title":"BlinoParser"},{"location":"pi-naps/#1-callbacks","text":"The prefered method for handling data is to use callbacks. We simply create a function to work with the relevant data and then register that function for use with Here a function is defined, simply to print the attention value: def onAttentionRecieved(attention): print(\"Attention value: %d\" % attention) ... Now when a parser is created, and processes a new attention value a callback is triggered. If we register the previously defined callback, it will execute on every new value recieved. We may register the function as follows: #Create parser. parser = BlinoParser() #Register the attentionCallback function with the parser. parser.attentionCallback = onAttentionRecieved","title":"1. Callbacks"},{"location":"pi-naps/#2-returning-packets","text":"The parseByte function returns the latest packet. It is advisable to check with a conditional that the packet has been updated before using it. This is advised as not every iteration a byte is parsed is new information updated in the packet. Check the object's \"updated\" member variable. returnedPacket = parser.parseByte(data) if(returnedPacket.updated): print(\"Delta Value = %d\" % returnedPacket.EEGPower.delta) Alternatively, the latest packet can be retrieved from the parsedPacket: currentPacket = parser.parsedPacket print(\"meditation value = %d\" % currentPacket.meditation)","title":"2. Returning Packets"},{"location":"pi-naps/#troubleshooting","text":"Pip Install If you're having trouble using pip install. Try using: python -m pip install --index-url https://pypi.org/simple/ example_pkg Where the url is the project url and the example_pkg is the package you wish to install. Python Library Path You might be having a lot of trouble finding where to install the libraries manually for global use. On raspbian it should look something like this: \"usr/local/lib/python2.7/dist-packages\" A lot of unnecessary trouble can come of this, especially if you are not confident in using linux and more specifically Raspbian. In which case, we advise to just clone the repository into a local directory and create your script in there, with the library files in the same directory. ___Additional Dependencies Error__ During pip install of Pi-Naps. If an error occours specifically around installing any addtional dependencies. Use --no-dependencies flag.","title":"Troubleshooting"},{"location":"tee-Naps/","text":"Tee-Naps Installation Step 1 - Arduino IDE Download + Install Arduino IDE Navigate to the the main download page at https://www.arduino.cc/en/Main/Software Choose the supported version for your system. Once downloaded, run the installer. Step 2 - Teensy Toolchain Download + Install Teensyduino, the Teensy toolchain. Go to https://www.pjrc.com/teensy/td_download.html and follow the link to relevant OS. Download and run the installer for Teensyduino. During the installation the Arduino IDE directory must be identified. If the installation fails, listing supported Arduino versions. Make sure a supported Arduino version is identified - Teensyduino should work with the latest version of Arduino found. Step 3 - TeeNaps Library Now the development environment for the Teensy is established, the TeeNaps library must be installed. Locate libraries directory Locate your system's Arduino \"Libraries\" directory. This will typically look something like: C:\\Program Files (x86)\\Arduino\\libraries If you are having trouble finding this, go to your Arduino application icon on the desktop. Right click, properties. Then note the path in the properties window. Install the TeeNaps library Find the git repository here: https://bitbucket.org/synapsdev/teenaps There are two ways of downloading the library. Download the zipped folder, then extract its contents into the Arduino library directory from the last step. Navigate into Arduino library directory on the command line, then git clone the repository. This will download the repository into the current directory. git clone https://bitbucket.org/synapsdev/teenaps.git The advantage of this method is when the library is updated in the future, the git pull command can be used to update it. Additional Resources For further resources, take a look at relevant links: Arduino - https://www.arduino.cc Teensyduino - https://www.pjrc.com/teensy TeeNaps - https://bitbucket.org/synapsdev/teenaps Library Useage There are two main classes that cover all required functionality. The TeeNapsController is for controlling the TeeNaps hardware. The BlinoParser is used for parsing/processing the data retrieved from the EEG sensor on the TeeNaps into meaningful information. TeeNapsController Use the TeeNapsController to setup how the TeeNaps operates. This includes functions for powering the EEG sensor and on-board LED, retrieving data from the EEG sensor over UART and configuring the EEG sensor operating modes. The TeeNapsController is a static class. This means you do not have to create an object to work on. Instead, control of the TeeNaps can be made using calls to the static functions provided in the class. 1.Include the installed TeeNaps.h: #include <TeeNaps.h> This should provide all TeeNaps functionality provided you have installed the TeeNaps into the arduino libraries directory correctly. 2.The controller must be powered and configured into an operating mode correctly: TeeNapsController::activateTGAT(); [Optional] Setup a serial connection over the USB UART interface to receive data from the Teensy to your computer - Useful for printing or logging: USBSERIAL.begin(TeeNapsController::BUADRATE_57_6K); 3.The TeeNaps EEG chip will operate in a default baudrate and mode, however this function can be used to set the desired mode: setMode(TeeNapsController::RAW_OUTPUT_57_6K); 4.Data from the EEG sensor can be detected using: if(TeeNapsController::isWaiting()) { ... } And then when data is detected, it can be read using: char data = TeeNapsController::readTGAT(); BlinoParser Use the BlinoParser class to process bytes retrieved from the EEG sensor into meaningful information. There are two methods of working with the parsed information: 1. Returning Packets The parseByte function returns the latest packet. It is advisable to check with a conditional that the packet has been updated before using it. This is advised as not every iteration a byte is parsed is new information updated in the packet. Check the object's \"updated\" member variable. ParsedPacket packet = parser.parseByte(data); if(packet.updated) { ... } 2. Callbacks There are a set of callback functions which when defined are executed when the associated information is parsed. Define these to use the information as desired. void eegSignalCallback(EEG eeg) { ... } In the setup code block, set the callback function in the blinoParser object to function defined previously: parser.eegSignalCallback = &eegSignalCallback; Now when the parser processes a new set of eeg values, the callback previously defined will execute: if(TeeNapsController::isWaiting()) { int data = TeeNapsController::readTGAT(); parser.parseByte(data); } Examples Blinky This example demonstrates the use of the TeeNaps on board LED. An appropriate first example to run with the TeeNaps Teensy hat. Logging This example demonstrates the use of enabling the logging of data recieved from the EEG sensor over the USB serial interface to a specified file. Returning Packets This example demonstrates the use of returned packets of processed EEG data from the parser. Uses a conditional if statement to detect when the packet has been updated with new values. Callbacks This example demonstrates the use of defining callback functions which execute when certain data items are processed through the parser. Command Bytes This example demonstrates the use of command bytes sent to the EEG sensor over the UART to control what mode the sensor operates in. Library Explanation What follows is an explanation of the Python source code which is available for modification and extension. Much of what is detaild here is covered in the code comments, however there may be further details found here. TeeNaps Controller Class The TeeNaps static class is used to control the TeeNaps from the Teensy. This includes getting data, configuring sensor EEG mode. Constants TGAT_POWER_PIN - This is the GPIO pin used to control power to the EEG sensor. LED_POWER_PIN - This is the GPIO pin used to control the UART pin. Pull down to deactivate the UART line when finished with. USB_SERIAL - Serial interface over the USB. Typically used to communicate with a computer the Teensy is connected to. TGAT_SERIAL - Serial interface over one of the Teensy UART pins. Used to communicate with the EEG sensor. BAUDRATE. ( BUADRATE_1_2K = 1200, BUADRATE_9_6K = 9600, BUADRATE_57_6K = 57600 ) - Enum of different baudrate values, OUTPUT_MODE. ( NORMAL_OUTPUT_1_2K, NORMAL_OUTPUT_9_6K, RAW_OUTPUT_57_6K, FFT_OUTPUT_57_6K ) - Enum of the different modes the EEG sensor can be set in. These are passed into the set mode function to configure the EEG sensor. Variables _interface - Indicates which interface is being used to communicate with EEG sensor. _UART - The UART object created for control of UART interface. _I2C - The I2C object created for control of the SC16IS750 I2C chip. Functions activateLED ( self, selectedLED ) - Activate the desired LED using the LED constants. deactivateLED ( self, selectedLED ) - Deactivate the desired LED using the LED constants. deactivateAllLED ( self ) - Deactivate all LEDs currently active. activateTGAT ( self ) - Power the EEG sensor on the PiNaps. It is important the EEG sensor is powered before receiving data and controlling the sensor. deactivateTGAT ( self ) - Powers down the EEG sensor. Desirable if not in use for an extended time to save battery. setupUART ( self ) - Sets up the UART interface for communication with the EEG sensor in the default operating mode, 57.6k baudrate with normal and raw wave data. deactivateUART ( self ) - Unconfigures use of UART interface for communication with EEG sensor. Making available the alternative I2C interface. setupI2C ( self ) - Sets up the I2C interface for communication with the EEG sensor in the default operating mode, 57.6k baudrate with normal and raw wave data. isWaiting ( self ) - Returns boolean indicating if there is data waiting to be received from the EEG sensor. dataWaiting ( self ) - Returns a number indicating the number of bytes waiting to be received from the EEG sensor. readTGAT ( self ) - Returns the next byte waiting to be received from the EEG sensor. setMode ( self, output_mode ) - Set the operating mode of the EEG sensor using output modes class. _decodeByte ( self, byte ) - Private class used to decode bytes received over UART. Blino Parser Class The BlinoParser class is used to parse the data received from the EEG sensor which comes as a stream structured in a defined protocol. The parser then processes it to extract useful information. This works by inputting the constant stream of bytes being received from the EEG sensor as they come. The parser records it all and once enough parts are received to process some EEG information, it becomes available in the parser object. Constants State. ( PARSER_STATE_NULL, PARSER_STATE_SYNC, PARSER_STATE_SYNC_CHECK, PARSER_STATE_PAYLOAD_LENGTH, PARSER_STATE_PAYLOAD, PARSER_STATE_CHKSUM, PARSER_STATE_WAIT_HIGH, PARSER_STATE_WAIT_LOW, PARSER_SYNC_BYTE, PARSER_EXCODE_BYTE ) - Class of constants that identify the states the BlinoParser can be in. As bytes are received, the parser keeps track of what state it is in from what was last received. DataDefinitions. ( PARSER_CODE_BATTERY, PARSER_CODE_POOR_QUALITY, PARSER_CODE_ATTENTION, PARSER_CODE_MEDITATION, PARSER_CODE_8BITRAW_SIGNAL, PARSER_CODE_RAW_MARKER, PARSER_CODE_RAW_SIGNAL, PARSER_CODE_EEG_POWERS, PARSER_CODE_ASIC_EEG_POWER_INT ) - Class of constants that identify the types of information the parser processes from the EEG sensor data. Variables PacketStructure. ( updated, code, battery, quality, attention, meditation, raw, EEG. ( delta, theta, lAlpha, hAlpha, lBeta, hBeta, lGamma, mGamma )) - Class which defines the structure of the packets received from the EEG sensor. The parsed data can be stored in objects of this class to give structured values. lastByte = 0 - Keeps track of the previous byte for a future verion where the EEG sensor may provide more data and the protocol extended. payloadLength = 0 - The expected length of the payload being receieved. Read from a byte as part of the payload describing the length of the payload to come. payloadBytesReceived = 0 - The number of bytes receieved from the payload so far. Used to track how much of the payload receieved, so it can move to next state when it has reached the expected payload length. dataPayload - The payload bytes buffer. This is processed through the parsePayload function. dataPayload - The sum of all bytes retrieved. Used as part of the checksum calculation to check packet integrity. dataPayload - The checksum value expected. Compared to the calculated checksum at end. logging - A boolean value which indicates if debugging information should be printed to standard console. [Data]Callback - All callback functions which can be defined using setters. When the associated data is processed by the parser, the related callback function executes. Functions activateLogging ( int baudrate ) - Activates logging EEG information to USB serial interface. Therefore if serial stream monitored over it will see debug information. Sets logging = true. deactivateLogging ( ) - Dectivates logging EEG information to USB serial interface. Sets logging = false. handleDataValue ( unsigned char extendedCodeLevel, unsigned char code, unsigned char numBytes, unsigned char* value, ) - Identifies the code of the current byte. It then processes it according to the protocol and extracts EEG information. ParsedPacket parseByte ( unsigned char byte ) - Depending on current state, processes received byte accordingly and transtions to new state if needed. int parsePacketPayload ( unsigned char byte ) - When the payload buffer is filled, processes the payload contents into meaningful data the parser packet is updated with. [Getters for latest full packet and individual EEG information.] Additional Notes","title":"Tee-Naps"},{"location":"tee-Naps/#tee-naps","text":"","title":"Tee-Naps"},{"location":"tee-Naps/#installation","text":"","title":"Installation"},{"location":"tee-Naps/#step-1-arduino-ide","text":"Download + Install Arduino IDE Navigate to the the main download page at https://www.arduino.cc/en/Main/Software Choose the supported version for your system. Once downloaded, run the installer.","title":"Step 1 - Arduino IDE"},{"location":"tee-Naps/#step-2-teensy-toolchain","text":"Download + Install Teensyduino, the Teensy toolchain. Go to https://www.pjrc.com/teensy/td_download.html and follow the link to relevant OS. Download and run the installer for Teensyduino. During the installation the Arduino IDE directory must be identified. If the installation fails, listing supported Arduino versions. Make sure a supported Arduino version is identified - Teensyduino should work with the latest version of Arduino found.","title":"Step 2 - Teensy Toolchain"},{"location":"tee-Naps/#step-3-teenaps-library","text":"Now the development environment for the Teensy is established, the TeeNaps library must be installed.","title":"Step 3 - TeeNaps Library"},{"location":"tee-Naps/#locate-libraries-directory","text":"Locate your system's Arduino \"Libraries\" directory. This will typically look something like: C:\\Program Files (x86)\\Arduino\\libraries If you are having trouble finding this, go to your Arduino application icon on the desktop. Right click, properties. Then note the path in the properties window.","title":"Locate libraries directory"},{"location":"tee-Naps/#install-the-teenaps-library","text":"Find the git repository here: https://bitbucket.org/synapsdev/teenaps There are two ways of downloading the library. Download the zipped folder, then extract its contents into the Arduino library directory from the last step. Navigate into Arduino library directory on the command line, then git clone the repository. This will download the repository into the current directory. git clone https://bitbucket.org/synapsdev/teenaps.git The advantage of this method is when the library is updated in the future, the git pull command can be used to update it.","title":"Install the TeeNaps library"},{"location":"tee-Naps/#additional-resources","text":"For further resources, take a look at relevant links: Arduino - https://www.arduino.cc Teensyduino - https://www.pjrc.com/teensy TeeNaps - https://bitbucket.org/synapsdev/teenaps","title":"Additional Resources"},{"location":"tee-Naps/#library","text":"","title":"Library"},{"location":"tee-Naps/#useage","text":"There are two main classes that cover all required functionality. The TeeNapsController is for controlling the TeeNaps hardware. The BlinoParser is used for parsing/processing the data retrieved from the EEG sensor on the TeeNaps into meaningful information.","title":"Useage"},{"location":"tee-Naps/#teenapscontroller","text":"Use the TeeNapsController to setup how the TeeNaps operates. This includes functions for powering the EEG sensor and on-board LED, retrieving data from the EEG sensor over UART and configuring the EEG sensor operating modes. The TeeNapsController is a static class. This means you do not have to create an object to work on. Instead, control of the TeeNaps can be made using calls to the static functions provided in the class. 1.Include the installed TeeNaps.h: #include <TeeNaps.h> This should provide all TeeNaps functionality provided you have installed the TeeNaps into the arduino libraries directory correctly. 2.The controller must be powered and configured into an operating mode correctly: TeeNapsController::activateTGAT(); [Optional] Setup a serial connection over the USB UART interface to receive data from the Teensy to your computer - Useful for printing or logging: USBSERIAL.begin(TeeNapsController::BUADRATE_57_6K); 3.The TeeNaps EEG chip will operate in a default baudrate and mode, however this function can be used to set the desired mode: setMode(TeeNapsController::RAW_OUTPUT_57_6K); 4.Data from the EEG sensor can be detected using: if(TeeNapsController::isWaiting()) { ... } And then when data is detected, it can be read using: char data = TeeNapsController::readTGAT();","title":"TeeNapsController"},{"location":"tee-Naps/#blinoparser","text":"Use the BlinoParser class to process bytes retrieved from the EEG sensor into meaningful information. There are two methods of working with the parsed information:","title":"BlinoParser"},{"location":"tee-Naps/#1-returning-packets","text":"The parseByte function returns the latest packet. It is advisable to check with a conditional that the packet has been updated before using it. This is advised as not every iteration a byte is parsed is new information updated in the packet. Check the object's \"updated\" member variable. ParsedPacket packet = parser.parseByte(data); if(packet.updated) { ... }","title":"1. Returning Packets"},{"location":"tee-Naps/#2-callbacks","text":"There are a set of callback functions which when defined are executed when the associated information is parsed. Define these to use the information as desired. void eegSignalCallback(EEG eeg) { ... } In the setup code block, set the callback function in the blinoParser object to function defined previously: parser.eegSignalCallback = &eegSignalCallback; Now when the parser processes a new set of eeg values, the callback previously defined will execute: if(TeeNapsController::isWaiting()) { int data = TeeNapsController::readTGAT(); parser.parseByte(data); }","title":"2. Callbacks"},{"location":"tee-Naps/#examples","text":"","title":"Examples"},{"location":"tee-Naps/#blinky","text":"This example demonstrates the use of the TeeNaps on board LED. An appropriate first example to run with the TeeNaps Teensy hat.","title":"Blinky"},{"location":"tee-Naps/#logging","text":"This example demonstrates the use of enabling the logging of data recieved from the EEG sensor over the USB serial interface to a specified file.","title":"Logging"},{"location":"tee-Naps/#returning-packets","text":"This example demonstrates the use of returned packets of processed EEG data from the parser. Uses a conditional if statement to detect when the packet has been updated with new values.","title":"Returning Packets"},{"location":"tee-Naps/#callbacks","text":"This example demonstrates the use of defining callback functions which execute when certain data items are processed through the parser.","title":"Callbacks"},{"location":"tee-Naps/#command-bytes","text":"This example demonstrates the use of command bytes sent to the EEG sensor over the UART to control what mode the sensor operates in.","title":"Command Bytes"},{"location":"tee-Naps/#library-explanation","text":"What follows is an explanation of the Python source code which is available for modification and extension. Much of what is detaild here is covered in the code comments, however there may be further details found here.","title":"Library Explanation"},{"location":"tee-Naps/#teenaps-controller-class","text":"The TeeNaps static class is used to control the TeeNaps from the Teensy. This includes getting data, configuring sensor EEG mode.","title":"TeeNaps Controller Class"},{"location":"tee-Naps/#constants","text":"TGAT_POWER_PIN - This is the GPIO pin used to control power to the EEG sensor. LED_POWER_PIN - This is the GPIO pin used to control the UART pin. Pull down to deactivate the UART line when finished with. USB_SERIAL - Serial interface over the USB. Typically used to communicate with a computer the Teensy is connected to. TGAT_SERIAL - Serial interface over one of the Teensy UART pins. Used to communicate with the EEG sensor. BAUDRATE. ( BUADRATE_1_2K = 1200, BUADRATE_9_6K = 9600, BUADRATE_57_6K = 57600 ) - Enum of different baudrate values, OUTPUT_MODE. ( NORMAL_OUTPUT_1_2K, NORMAL_OUTPUT_9_6K, RAW_OUTPUT_57_6K, FFT_OUTPUT_57_6K ) - Enum of the different modes the EEG sensor can be set in. These are passed into the set mode function to configure the EEG sensor.","title":"Constants"},{"location":"tee-Naps/#variables","text":"_interface - Indicates which interface is being used to communicate with EEG sensor. _UART - The UART object created for control of UART interface. _I2C - The I2C object created for control of the SC16IS750 I2C chip.","title":"Variables"},{"location":"tee-Naps/#functions","text":"activateLED ( self, selectedLED ) - Activate the desired LED using the LED constants. deactivateLED ( self, selectedLED ) - Deactivate the desired LED using the LED constants. deactivateAllLED ( self ) - Deactivate all LEDs currently active. activateTGAT ( self ) - Power the EEG sensor on the PiNaps. It is important the EEG sensor is powered before receiving data and controlling the sensor. deactivateTGAT ( self ) - Powers down the EEG sensor. Desirable if not in use for an extended time to save battery. setupUART ( self ) - Sets up the UART interface for communication with the EEG sensor in the default operating mode, 57.6k baudrate with normal and raw wave data. deactivateUART ( self ) - Unconfigures use of UART interface for communication with EEG sensor. Making available the alternative I2C interface. setupI2C ( self ) - Sets up the I2C interface for communication with the EEG sensor in the default operating mode, 57.6k baudrate with normal and raw wave data. isWaiting ( self ) - Returns boolean indicating if there is data waiting to be received from the EEG sensor. dataWaiting ( self ) - Returns a number indicating the number of bytes waiting to be received from the EEG sensor. readTGAT ( self ) - Returns the next byte waiting to be received from the EEG sensor. setMode ( self, output_mode ) - Set the operating mode of the EEG sensor using output modes class. _decodeByte ( self, byte ) - Private class used to decode bytes received over UART.","title":"Functions"},{"location":"tee-Naps/#blino-parser-class","text":"The BlinoParser class is used to parse the data received from the EEG sensor which comes as a stream structured in a defined protocol. The parser then processes it to extract useful information. This works by inputting the constant stream of bytes being received from the EEG sensor as they come. The parser records it all and once enough parts are received to process some EEG information, it becomes available in the parser object.","title":"Blino Parser Class"},{"location":"tee-Naps/#constants_1","text":"State. ( PARSER_STATE_NULL, PARSER_STATE_SYNC, PARSER_STATE_SYNC_CHECK, PARSER_STATE_PAYLOAD_LENGTH, PARSER_STATE_PAYLOAD, PARSER_STATE_CHKSUM, PARSER_STATE_WAIT_HIGH, PARSER_STATE_WAIT_LOW, PARSER_SYNC_BYTE, PARSER_EXCODE_BYTE ) - Class of constants that identify the states the BlinoParser can be in. As bytes are received, the parser keeps track of what state it is in from what was last received. DataDefinitions. ( PARSER_CODE_BATTERY, PARSER_CODE_POOR_QUALITY, PARSER_CODE_ATTENTION, PARSER_CODE_MEDITATION, PARSER_CODE_8BITRAW_SIGNAL, PARSER_CODE_RAW_MARKER, PARSER_CODE_RAW_SIGNAL, PARSER_CODE_EEG_POWERS, PARSER_CODE_ASIC_EEG_POWER_INT ) - Class of constants that identify the types of information the parser processes from the EEG sensor data.","title":"Constants"},{"location":"tee-Naps/#variables_1","text":"PacketStructure. ( updated, code, battery, quality, attention, meditation, raw, EEG. ( delta, theta, lAlpha, hAlpha, lBeta, hBeta, lGamma, mGamma )) - Class which defines the structure of the packets received from the EEG sensor. The parsed data can be stored in objects of this class to give structured values. lastByte = 0 - Keeps track of the previous byte for a future verion where the EEG sensor may provide more data and the protocol extended. payloadLength = 0 - The expected length of the payload being receieved. Read from a byte as part of the payload describing the length of the payload to come. payloadBytesReceived = 0 - The number of bytes receieved from the payload so far. Used to track how much of the payload receieved, so it can move to next state when it has reached the expected payload length. dataPayload - The payload bytes buffer. This is processed through the parsePayload function. dataPayload - The sum of all bytes retrieved. Used as part of the checksum calculation to check packet integrity. dataPayload - The checksum value expected. Compared to the calculated checksum at end. logging - A boolean value which indicates if debugging information should be printed to standard console. [Data]Callback - All callback functions which can be defined using setters. When the associated data is processed by the parser, the related callback function executes.","title":"Variables"},{"location":"tee-Naps/#functions_1","text":"activateLogging ( int baudrate ) - Activates logging EEG information to USB serial interface. Therefore if serial stream monitored over it will see debug information. Sets logging = true. deactivateLogging ( ) - Dectivates logging EEG information to USB serial interface. Sets logging = false. handleDataValue ( unsigned char extendedCodeLevel, unsigned char code, unsigned char numBytes, unsigned char* value, ) - Identifies the code of the current byte. It then processes it according to the protocol and extracts EEG information. ParsedPacket parseByte ( unsigned char byte ) - Depending on current state, processes received byte accordingly and transtions to new state if needed. int parsePacketPayload ( unsigned char byte ) - When the payload buffer is filled, processes the payload contents into meaningful data the parser packet is updated with. [Getters for latest full packet and individual EEG information.]","title":"Functions"},{"location":"tee-Naps/#additional-notes","text":"","title":"Additional Notes"}]}